\section{Описание}

\textbf{Алгори́тм Дейкстры} (англ. Dijkstra’s algorithm) — алгоритм на графах, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. Находит кратчайшие пути от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса. Алгоритм широко применяется в программировании, например, его используют протоколы маршрутизации OSPF и IS-IS.\newline

Каждой вершине из V сопоставим метку — минимальное известное расстояние от этой вершины до a. Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки. Работа алгоритма завершается, когда все вершины посещены.\newline

\textbf{Инициализация}\newline
Метка самой вершины a полагается равной 0, метки остальных вершин — бесконечности. Это отражает то, что расстояния от a до других вершин пока неизвестны. Все вершины графа помечаются как непосещённые.\newline

\textbf{Шаг алгоритма}\newline
Если все вершины посещены, алгоритм завершается. В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку. Мы рассматриваем всевозможные маршруты, в которых u является предпоследним пунктом. Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом.\newline

Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.\newline
\pagebreak

\section{Исходный код}
Фрагмент кода, где реализован алгоритм Дейкстры, с использованием очереди с приорететом:\newline


\begin{lstlisting}[language=C++]
    while(!prior.empty()){
        int minDistVert = prior.top().to;
        prior.pop();

        if(used[minDistVert]){
            continue;
        }

        if(minDistVert == LINF){
            break;
        }        

        used[minDistVert] = true;

        for (auto [to, cost]: graph[minDistVert]){
            ll newDist = cost + dist[minDistVert];

            if(dist[to] > newDist){
                dist[to] = newDist;
                prior.push(Edge(to, newDist));
            }
        }
    }
\end{lstlisting}

\section{Консоль}
tmp:
\begin{alltt}
5 6 1 5
1 2 2
1 3 0
3 2 10
4 2 1
3 4 4
4 5 5
\end{alltt}
console output:
\begin{alltt}
8
\end{alltt}
\pagebreak
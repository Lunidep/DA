\section{Тест производительности}

Тест представлял из себя сравнение реализованного мной класса AVL-дерева с std::map, который реализован на красно-черном дереве.\newline

Задачей было построить деревья из n различных элементов, сделать поиск n различных значений в этих деревьях, удалить n различных элементов(элементы сразу же добавлялись обратно, но отслеживалось только время удаления). В результате работы $benchmark.cpp$ видны следующие результаты:

\begin{alltt}
root@Lunidep:~/DA/da_lab2# ./benchmark
----------------numder_of_nodes = 1000 —------------—
Insert:
std::map ms=75
avl ms=28

Find:
std::map ms=1
avl ms=0

Delete:
std::map ms=5
avl ms=3

----------------numder_of_nodes = 10000 —------------—
Insert:
std::map ms=518
avl ms=3060

Find:
std::map ms=202
avl ms=45

Delete:
std::map ms=165
avl ms=201

----------------numder_of_nodes = 100000 —------------—
Insert:
std::map ms=5940
avl ms=90917

Find:
std::map ms=2535
avl ms=822

Delete:
std::map ms=6610
avl ms=17866

----------------numder_of_nodes = 1000000 —------------—
Insert:
std::map ms=96845
avl ms=996143

Find:
std::map ms=43218
avl ms=11257

Delete:
std::map ms=118482
avl ms=821968
\end{alltt}

Из примера видно, что AVL-дерево проявляет себя в разы эффективнее при поиске элементов, однако уступает в эффективности вставки и удаления (в связи с необходимостью постоянно перестраиваться).


\pagebreak
